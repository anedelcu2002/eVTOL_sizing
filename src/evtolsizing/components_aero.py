import numpy as np
import openmdao.api as om

# ------------------------------
# drag estimation components
# ------------------------------

class WingedCruiseDrag(om.ExplicitComponent):
    """
    computes the drag of a winged configuration in cruise. Just a simple polar drag model.
    Inputs: lift, wing area, cruise speed
    Outputs: drag, cruise CL
    """

    def initialize(self):
        self.options.declare('n_UAVs', types=int, default=1, desc='number of UAVs')
        self.options.declare('rho_air', default=1.225, desc='air density')
        self.options.declare('Cd0', types=float, desc='minimum Cd of the drag polar')
        self.options.declare('wing_AR', types=float, desc='wing aspect ratio')
        self.options.declare('wing_e', types=float, desc='Oswald efficiency')

    def setup(self):
        n_UAVs = self.options['n_UAVs']

        self.add_input('lift', shape=(n_UAVs,), units='N', desc='lift generated by the wing')
        self.add_input('UAVs|S_wing', shape=(n_UAVs,), units='m**2', desc='wing reference area')
        self.add_input('UAVs|speed', val=33 * np.ones(n_UAVs), units='m/s', desc='cruise speed')
        self.add_output('drag', shape=(n_UAVs,), units='N', desc='drag')
        self.add_output('CL_cruise', shape=(n_UAVs,), desc='lift coefficient')
        self.declare_partials('*', '*', rows=np.arange(n_UAVs), cols=np.arange(n_UAVs))

        self.rho_air = 1.2  # air density
        self.Cd0 = 0.01  # zero-lift drag coefficient (of just wing, not including the body)
        self.wing_AR = 8
        self.wing_e = 0.8

    def compute(self, inputs, outputs):
        rho_air = self.options['rho_air']
        Cd0 = self.options['Cd0']
        wing_AR = self.options['wing_AR']
        wing_e = self.options['wing_e']
        lift = inputs['lift']
        speed = inputs['UAVs|speed']
        area = inputs['UAVs|S_wing']

        q = 0.5 * rho_air * speed**2  # dynamic pressure
        Cl = lift / q / area   # CL required for vertical trim
        Cd = Cd0 + Cl**2 / np.pi / wing_AR / wing_e
        outputs['drag'] = q * area * Cd
        outputs['CL_cruise'] = Cl

    def compute_partials(self, inputs, partials):
        rho_air = self.options['rho_air']
        Cd0 = self.options['Cd0']
        wing_AR = self.options['wing_AR']
        wing_e = self.options['wing_e']
        lift = inputs['lift']
        speed = inputs['UAVs|speed']
        area = inputs['UAVs|S_wing']

        q = 0.5 * rho_air * speed**2
        dq_dspeed = rho_air * speed
        Cl = lift / q / area
        dCl_dlift = 1 / q / area
        dCl_dq = (lift / area) * (-1. / q**2)
        dCl_darea = (lift / q) * (-1. / area**2)
        Cd = Cd0 + Cl**2 / np.pi / wing_AR / wing_e
        dCd_dCl = 2 * Cl / np.pi / wing_AR / wing_e
        # drag = q * area * Cd
        ddrag_dq = area * Cd
        ddrag_darea = q * Cd
        ddrag_Cd = q * area
        
        partials['drag', 'lift'] = ddrag_Cd * dCd_dCl * dCl_dlift
        partials['drag', 'UAVs|S_wing'] = ddrag_darea + ddrag_Cd * dCd_dCl * dCl_darea
        partials['drag', 'UAVs|speed'] = (ddrag_Cd * dCd_dCl * dCl_dq + ddrag_dq) * dq_dspeed
        partials['CL_cruise', 'lift'] = dCl_dlift
        partials['CL_cruise', 'UAVs|S_wing'] = dCl_darea
        partials['CL_cruise', 'UAVs|speed'] = dCl_dq * dq_dspeed


class BodyDrag(om.ExplicitComponent):
    """
    computes the body drag for multirotor
    Inputs: rotor radius, cruise speed, body tilt angle
    Outputs: body drag
    """

    def initialize(self):
        self.options.declare('n_UAVs', types=int, default=1, desc='number of UAVs')

    def setup(self):
        n_UAVs = self.options['n_UAVs']

        self.add_input('UAVs|rotor_radius', shape=(n_UAVs,), units='m', desc='rotor radius')
        self.add_input('UAVs|speed', val=33 * np.ones(n_UAVs), units='m/s', desc='cruise speed')
        self.add_input('body|sin_beta', shape=(n_UAVs,), desc='sin(beta). beta = incidence angle of the body')  # beta=0deg when flying like a wing, ~90deg for multirotor without the wings
        self.add_output('drag', shape=(n_UAVs,), units='N', desc='drag of the body')
        self.declare_partials('*', '*', rows=np.arange(n_UAVs), cols=np.arange(n_UAVs))

        self.rho_air = 1.2  # air density

    def compute(self, inputs, outputs):
        r = inputs['UAVs|rotor_radius']
        speed = inputs['UAVs|speed']
        sin_beta = inputs['body|sin_beta']
        
        S_body = 1.682 * r**2    # body area
        Cd_body = 0.1 + 0.2 * sin_beta**3    # drag coefficient
        outputs['drag'] = 0.5 * self.rho_air * speed**2 * S_body * Cd_body
    
    def compute_partials(self, inputs, partials):
        r = inputs['UAVs|rotor_radius']
        speed = inputs['UAVs|speed']
        sin_beta = inputs['body|sin_beta']
        S_body = 1.682 * r**2    # body area
        dS_dr = 1.682 * 2 * r
        Cd_body = 0.1 + 0.2 * sin_beta**3    # drag coefficient
        dCd_dsinbeta = 0.2 * 3 * sin_beta**2

        partials['drag', 'UAVs|rotor_radius'] = 0.5 * self.rho_air * speed**2 * Cd_body * dS_dr
        partials['drag', 'UAVs|speed'] = self.rho_air * speed * S_body * Cd_body
        partials['drag', 'body|sin_beta'] = 0.5 * self.rho_air * speed**2 * S_body * dCd_dsinbeta


